<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 6.3.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"example.com","root":"/","scheme":"Gemini","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}};
  </script>

  <meta name="description" content="FPGA复习资料本复习资料由 wykcat 总结。想要更多其它资料请前往吾猫的猫窝。 在此特别感谢 CaptainLi，Golden 在制作本份文档中所作出的特别贡献。 思维导图 一、单选题（仅给出答案） 在Verilog中，哪个关键字用于定义模块的开始：module。  Verilog是一种用于描述数字电路的语言，它是一种：硬件描述语言&#x2F;高级语言。  Verilog的设计单元包括：模块">
<meta property="og:type" content="article">
<meta property="og:title" content="FPGA-复习资料">
<meta property="og:url" content="http://example.com/2024/05/17/FPGA-%E5%A4%8D%E4%B9%A0%E8%B5%84%E6%96%99/index.html">
<meta property="og:site_name" content="吾猫的猫窝">
<meta property="og:description" content="FPGA复习资料本复习资料由 wykcat 总结。想要更多其它资料请前往吾猫的猫窝。 在此特别感谢 CaptainLi，Golden 在制作本份文档中所作出的特别贡献。 思维导图 一、单选题（仅给出答案） 在Verilog中，哪个关键字用于定义模块的开始：module。  Verilog是一种用于描述数字电路的语言，它是一种：硬件描述语言&#x2F;高级语言。  Verilog的设计单元包括：模块">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="http://example.com/2024/05/17/FPGA-%E5%A4%8D%E4%B9%A0%E8%B5%84%E6%96%99/FPGA_00.png">
<meta property="og:image" content="http://example.com/2024/05/17/FPGA-%E5%A4%8D%E4%B9%A0%E8%B5%84%E6%96%99/17128281194GOS.png">
<meta property="og:image" content="http://example.com/2024/05/17/FPGA-%E5%A4%8D%E4%B9%A0%E8%B5%84%E6%96%99/1713147786RRSU.png">
<meta property="og:image" content="http://example.com/2024/05/17/FPGA-%E5%A4%8D%E4%B9%A0%E8%B5%84%E6%96%99/1712828194F9VM.png">
<meta property="og:image" content="http://example.com/2024/05/17/FPGA-%E5%A4%8D%E4%B9%A0%E8%B5%84%E6%96%99/1712828213XGGP.png">
<meta property="og:image" content="http://example.com/2024/05/17/FPGA-%E5%A4%8D%E4%B9%A0%E8%B5%84%E6%96%99/1712828261PITO.png">
<meta property="og:image" content="http://example.com/2024/05/17/FPGA-%E5%A4%8D%E4%B9%A0%E8%B5%84%E6%96%99/17128283311VUZ.png">
<meta property="article:published_time" content="2024-05-17T11:31:54.000Z">
<meta property="article:modified_time" content="2024-05-17T16:39:42.511Z">
<meta property="article:author" content="wykcat">
<meta property="article:tag" content="FPGA">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://example.com/2024/05/17/FPGA-%E5%A4%8D%E4%B9%A0%E8%B5%84%E6%96%99/FPGA_00.png">

<link rel="canonical" href="http://example.com/2024/05/17/FPGA-%E5%A4%8D%E4%B9%A0%E8%B5%84%E6%96%99/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'zh-CN'
  };
</script>

  <title>FPGA-复习资料 | 吾猫的猫窝</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

<!-- hexo injector head_end start -->
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.css">

<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/hexo-math@4.0.0/dist/style.css">
<!-- hexo injector head_end end --></head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">吾猫的猫窝</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>关于</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a>

  </li>
        <li class="menu-item menu-item-update">

    <a href="/update/notes.html" rel="section"><i class="fa fa-calendar fa-fw"></i>更新日志</a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content post posts-expand">
            

    
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2024/05/17/FPGA-%E5%A4%8D%E4%B9%A0%E8%B5%84%E6%96%99/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="wykcat">
      <meta itemprop="description" content="摆烂是种特别的选择">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="吾猫的猫窝">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          FPGA-复习资料
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2024-05-17 19:31:54" itemprop="dateCreated datePublished" datetime="2024-05-17T19:31:54+08:00">2024-05-17</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2024-05-18 00:39:42" itemprop="dateModified" datetime="2024-05-18T00:39:42+08:00">2024-05-18</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E9%A2%98%E5%BA%93/" itemprop="url" rel="index"><span itemprop="name">题库</span></a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>23k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>21 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <h1 id="FPGA复习资料"><a href="#FPGA复习资料" class="headerlink" title="FPGA复习资料"></a>FPGA复习资料</h1><p>本复习资料由 <em><strong>wykcat</strong></em> 总结。想要更多其它资料请前往<a target="_blank" rel="noopener" href="https://www.wykcat.top/">吾猫的猫窝</a>。</p>
<p>在此特别感谢 <em><strong>CaptainLi</strong></em>，<em><strong>Golden</strong></em> 在制作本份文档中所作出的特别贡献。</p>
<h2 id="思维导图"><a href="#思维导图" class="headerlink" title="思维导图"></a>思维导图</h2><p><img src="/2024/05/17/FPGA-%E5%A4%8D%E4%B9%A0%E8%B5%84%E6%96%99/FPGA_00.png" alt="FPGA_00"></p>
<h2 id="一、单选题（仅给出答案）"><a href="#一、单选题（仅给出答案）" class="headerlink" title="一、单选题（仅给出答案）"></a>一、单选题（仅给出答案）</h2><ol>
<li><p>在Verilog中，哪个关键字用于定义模块的开始：<u>module</u>。</p>
</li>
<li><p>Verilog是一种用于描述数字电路的语言，它是一种：<u>硬件描述语言&#x2F;高级语言</u>。</p>
</li>
<li><p>Verilog的设计单元包括：<u><strong>模块（记这个就行了）</strong>，端口，参数，实例，连续赋值语句，过程块，任务和函数</u>。</p>
</li>
<li><p>Verilog的赋值语句中，”&#x3D;”表示：<u>阻塞赋值</u>。”&lt;&#x3D;”表示：<u>非阻塞赋值</u>。</p>
</li>
<li><p>Verilog中的always块用于：<u>顺序执行代码块</u>。</p>
</li>
<li><p>在Verilog语言中，a &#x3D; 4’b1011，那么^a &#x3D; <u>1’b1</u>。<strong>（按位异或的计算）</strong></p>
</li>
<li><p>一个 8位二进制加法计数器， 初始状态为 00000000， 问经过 268个输入脉冲后， 此计数器的状态为：<u>00001100</u>。<strong>（溢出位舍去）</strong></p>
</li>
<li><p>下列标识符中，<u>9moon</u>是不合法的标识符。<strong>（标识符必须以字母或下划线开头，后面可以是字母、数字或下划线的组合；标识符不能是Verilog中的关键字或保留字，如 <code>module</code>、<code>always</code> 等）</strong></p>
</li>
<li><p>下列语句中，不属于并行语句的是：<u>case语句</u>。</p>
</li>
<li><p>已知 “a &#x3D;1’b1;  b&#x3D;3’b001;”那么 {a,b} ＝ <u>4‘b1001</u>。<strong>（拼接操作）</strong></p>
</li>
<li><p>关于过程块以及过程赋值描述中，下列正确的是：<u>在过程赋值语句中表达式左边的信号一定是寄存器类型</u>。</p>
</li>
<li><p>Verilog 语言与  语言的区别，不正确的描述是：<u>Verilog 语言源于 C 语言，包括它的逻辑和延迟。</u></p>
</li>
<li><p>下列模块的例化正确的是： <u>Mydesign design(.sin(sin), .sout(sout))</u>。</p>
</li>
<li><p>下列 Verilog HL语言中寄存器类型数据定义与注释矛盾的是： <u>reg {1:5} dig &#x2F;&#x2F;dig 为 4 位寄存器</u>。</p>
</li>
<li><p>下列关于非阻塞赋值运算方式(如 b&lt;&#x3D;a;)说法错误的是： <u>b 的值在赋值语句执行完后立刻就改变的。</u></p>
</li>
<li><p>下列关于阻塞赋值运算方式(如 b&#x3D;a;)说法错误的是：<u>在“always”模块中的 reg 型信号都采用此赋值方式</u>。</p>
</li>
<li><p>assign s&#x3D; (a &gt;&#x3D;2 ) ? 1 : (a &lt; 0) ? 2: 0 ：<u>a&#x3D;2</u>。</p>
</li>
<li><p>在 Verilog HDL 语言中的位拼接运算符是：<u>{ }</u>。</p>
</li>
<li><p>Verilog中用于表示逻辑非的关键字是：<u>!</u>。</p>
</li>
<li><p>Verilog中，用于声明输入端口的关键字是：<u>input</u>。</p>
</li>
<li><p>在Verilog中，哪个操作符用于表示逻辑与：<u>&amp;&amp;</u>。</p>
</li>
<li><p>哪个关键字用于在Verilog中声明一个寄存器类型的变量： <u>reg</u>。</p>
</li>
<li><p>在Verilog中，哪个语句用于描述顺序执行的操作： <u>initial</u>。</p>
</li>
<li><p>Verilog中，哪个语句用于条件判断：<u>if-else</u>。</p>
</li>
<li><p>Verilog中用于描述组合逻辑的关键字是：<u>assign</u>。</p>
</li>
<li><p>Verilog中，哪个关键字用于定义模块的结束： <u>endmodule</u>。</p>
</li>
<li><p>Verilog中，哪个关键字用于定义任务： <u>task</u>。</p>
</li>
<li><p>Verilog中，哪个关键字用于定义时间延迟： <u>#</u>。</p>
</li>
<li><p>在Verilog  HDL的逻拇运算中，设&#x3D;8’b11010001,&#x3D;8’b00011001,则表达式”&amp;”的结果为：<u>8’b00010001</u>。</p>
</li>
<li><p>已知&#x3D;3’b110,&#x3D;3’b000,则||结果为：<u>1</u>。</p>
</li>
<li><p>Verilog HL定义了一系列保留字，叫做关键词，指出下列哪一个不属于关键词：<u>Wire</u>。</p>
</li>
<li><p>没有声明位宽的wire类型默认是 <u>1</u> 位。</p>
</li>
<li><p>由于线网类型代表的是物理连接线，因此它不存贮逻辑值，必须由器件所驱动。当一个wire类型的信号没有被驱动时，缺省值为 <u>Z</u>。</p>
</li>
<li><p>信号没有定义数据类型时，缺省为 <u>wire</u> 类型。</p>
</li>
<li><p>寄存器类型在赋新值以前保持<u>原值</u>。</p>
</li>
<li><p>输出端口可以由net&#x2F;register驱动，但输入端口只能是 <u>net</u> 类型。</p>
</li>
<li><p>reg类型的数组通常用于描述存储器，reg[15:0]MEM[0:1023];定义存储器字的位宽为：<u>16</u>。</p>
</li>
<li><p>下列关于同步有限状态机的描述错误的是：<u>状态是否变化要根据输入信号，只要输入条件满足，就会立刻转入到下一 个状态</u>。</p>
</li>
<li><p>下列关于流水线的描述错误的是：<u>增加流水线长度可以节省更多延迟，流水线越长，首次延迟越大，系统频 率就会降低</u>。</p>
</li>
<li><p>以下关于Top-own的设计方法不正确的描述是： <u>Top-Down设计中的系统总体仿真与所选工艺有关</u>。</p>
</li>
<li><p>always  begin  5  clk&#x3D;0；10 clk&#x3D;~clk; end产生的波形：<u>占空比1&#x2F;3</u>。</p>
</li>
<li><p>时间尺度定义为&#96;timescale 10ns&#x2F;100ps，<u>时间精度100ps</u>。</p>
</li>
<li><p>可综合代码中下列说法正确的是： <u>不能出现“# d”延时控制语句</u>。</p>
</li>
<li><p>下列语句中，不属于并行语句的是：<u>case语句</u>。</p>
</li>
<li><p>Verilog中，用于声明常量的关键字是： <u>parameter</u>。</p>
</li>
<li><p>在Verilog中，哪个符号用于注释单行： <u>&#x2F;&#x2F;</u>。</p>
</li>
<li><p>Verilog中，哪个操作符用于按位与运算：<u>&amp;</u>。</p>
</li>
<li><p>Verilog中用于声明整数的关键字是： <u>integer</u>。</p>
</li>
<li><p>Verilog中，哪个操作符用于逻辑或运算： <u>||</u>。</p>
</li>
<li><p>在Verilog的always块中，哪个关键字用于定义时钟的上升边沿触发： <u>posedge</u>。</p>
</li>
<li><p>在Verilog中，哪个符号用于表示按位或操作：<u>|</u>。</p>
</li>
<li><p>Verilog中，哪个关键字用于定义无限循环： <u>forever</u>。</p>
</li>
<li><p>Verilog中，哪个操作符用于按位异或运算：<u>^</u>。</p>
</li>
<li><p>在Verilog的函数定义中，哪个关键字用于返回函数的值： <u>return</u>。</p>
</li>
<li><p>Verilog中的数据类型wire和reg的区别在于： <u>wire用于内部信号连接，reg用于存储数据</u>。</p>
</li>
<li><p>如下程序代码，200ns后，信号q1的值为<u>8’d10</u>。</p>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">`<span class="keyword">timescale</span> 10ns/1ns</span></span><br><span class="line"><span class="keyword">module</span> test;</span><br><span class="line"><span class="keyword">reg</span> </span><br><span class="line">[<span class="number">7</span>:<span class="number">0</span>]data;</span><br><span class="line"><span class="keyword">reg</span> clk;</span><br><span class="line"><span class="keyword">initial</span></span><br><span class="line"><span class="keyword">begin</span></span><br><span class="line">  clk = <span class="number">0</span>;</span><br><span class="line">  #<span class="number">10</span>  data = <span class="number">8</span>’d10;</span><br><span class="line">  #<span class="number">20</span>  data = <span class="number">8</span>’h15;</span><br><span class="line">  #<span class="number">40</span>  data = <span class="number">8</span>’h25;</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"><span class="keyword">always</span> #<span class="number">5</span> clk = ~clk;</span><br><span class="line"><span class="keyword">reg</span> [<span class="number">7</span>:<span class="number">0</span>] q1,q2,q3;</span><br><span class="line"><span class="keyword">always</span> @ (<span class="keyword">posedge</span> clk)</span><br><span class="line"><span class="keyword">begin</span></span><br><span class="line">  q2 = q1;</span><br><span class="line">  q1 = data;</span><br><span class="line">  q3 = q2;</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"><span class="keyword">endmodule</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>在Verilog中，哪个关键字用于定义在仿真过程中值可以改变的变量：<u>reg</u>。</p>
</li>
<li><p>在Verilog中，always块的触发条件是什么：<u>可以由信号的任何变化触发</u>。</p>
</li>
<li><p>在Verilog中，以下哪个选项正确地实现了一个2输入N门的行为： <u>assign Y &#x3D; A &amp; B</u>。</p>
</li>
<li><p>在Verilog中，向量的位宽和方向如何定义：<u>{高位:低位}名称</u>。</p>
</li>
<li><p>在Verilog中，哪个关键字用于创建只在指定条件下激活的过程块：always</u>。</p>
</li>
<li><p>以下哪个选项是Verilog中合法的向量声明：<u>wire [3:0] vect</u>。</p>
</li>
<li><p>在Verilog中，initial块是如何执行的： <u>仅在仿真开始时执行一次</u> 。</p>
</li>
<li><p>在Verilog中，$finish是用来做什么的：<u>结束仿真</u>。</p>
</li>
<li><p>哪个关键字用于在Verilog中定义一个时序逻辑块： <u>always @(posedge clock)</u>。</p>
</li>
<li><p>Verilog中的三态缓冲器是如何表示的： <u>assign Y &#x3D; enable ? A : ‘Z’</u>。</p>
</li>
<li><p>在Verilog中，哪个关键字表示敏感列表中的任意变化：<u>*</u>。</p>
</li>
<li><p>哪种类型的赋值在Verilog中用于组合逻辑： <u>Blocking</u>。</p>
</li>
<li><p>在Verilog中，哪个关键字用于指定模块的输出： <u>output</u>。</p>
</li>
<li><p>Verilog中的模块实例化和连接正确的方式是什么： <u>模块名 实例名(端口连接)</u>。</p>
</li>
<li><p>在Verilog中，如何注释一段代码： <u>&#x2F;&#x2F; This is a comment   &#x2F;* This is a comment *&#x2F;</u> 。</p>
</li>
<li><p>Verilog中的$monitor语句是用来做什么的： <u>监控变量的变化并打印</u>。</p>
</li>
<li><p>在Verilog中定义一个名为“counter”的模块，其端口列表中没有端口的语法是：<u>module counter()</u>。</p>
</li>
<li><p>在Verilog中，连续赋值语句是什么：<u>assign</u>。</p>
</li>
<li><p>在Verilog中，如何声明一个带有8位宽并初始值为0的寄存器变量： <u>reg [7:0] var &#x3D; 0</u>。</p>
</li>
<li><p>在Verilog中定义一个参数化模块时使用的关键字是什么： <u>parameter</u>。</p>
</li>
<li><p>如何在Verilog中表示十六进制数5： <u>8’h5</u>。</p>
</li>
<li><p>在Verilog中，正确的方式来声明一个具有3个输入和1个输出的异或门是什么： <u>xor (output, input1, input2, input3)</u>。</p>
</li>
<li><p>在Verilog中，哪个语句用于条件编译：<u>&#96;ifdef</u>。</p>
</li>
<li><p>在Verilog中，如何正确初始化一个具有4个元素的整数数组： <u>integer array[0:3] &#x3D; {0, 1, 2, 3}</u>。</p>
</li>
<li><p>哪个Verilog构造用于描述硬件的物理布局： <u>primitive</u>。</p>
</li>
<li><p>在Verilog中，一个模块可以如何引用另一个模块： <u>通过实例化</u>。</p>
</li>
<li><p>Verilog中的$time系统函数是用来做什么的：<u>返回仿真的当前时间</u>。</p>
</li>
<li><p>哪个Verilog操作符用于位宽减少的逻辑或：<u>|</u>。</p>
</li>
<li><p>在Verilog中，如何表示一个模块的端口既可以是输入也可以是输出： <u>inout</u>。</p>
</li>
<li><p>哪个关键字在Verilog中用于指示一个块仅在仿真开始时执行一次：<u>initial</u>。</p>
</li>
<li><p>在Verilog中，哪个关键字用来描述一个可以在仿真期间多次执行的代码块： <u>always</u>。</p>
</li>
<li><p>哪个Verilog构造用于基于表达式的值选择一个执行语句：<u>case</u>。</p>
</li>
<li><p>Verilog中的模块参数化（parameterization）允许做什么：<u>使模块能够接受在实例化时设置的值</u>。</p>
</li>
<li><p>在Verilog中使用&lt;!–swig￼22–&gt;finish有什么区别：<u>&lt;!–swig￼23–&gt;finish终止仿真</u>。</p>
</li>
<li><p>Verilog的generate语句用于什么： <u>根据条件生成代码</u>。</p>
</li>
<li><p>如何在Verilog中声明一个内部使用的局部参数：<u>localparam</u>。</p>
</li>
<li><p>在Verilog中，用于描述一个模块能够处理的信号边缘类型（如上升沿或下降沿）的关键字是： <u>posedge &#x2F; negedge</u>。</p>
</li>
<li><p>如何在Verilog中声明一个模拟时钟信号： <u>always #10 clk &#x3D; !clk</u>。</p>
</li>
<li><p>在Verilog中，具有默认值的case语句应该使用哪个关键字：<u>default</u>。</p>
</li>
<li><p>Verilog中的“task”和“function”有何不同： <u>task可以有多个输出，而function只能有返回值</u>。</p>
</li>
<li><p>FPGA 是指什么： <u>Field Programmable Gate Array</u>。</p>
</li>
<li><p>Verilog 是一种什么类型的语言： <u>高级硬件描述语言</u>。</p>
</li>
<li><p>Verilog 中的非阻塞赋值（&lt;&#x3D;）和阻塞赋值（&#x3D;）的区别是什么：<u>非阻塞赋值可以并行执行，阻塞赋值按顺序执行</u>。</p>
</li>
<li><p>FPG 中的时钟资源通常由什么提供：<u>振荡器</u>。</p>
</li>
<li><p>Verilog 中的 always @(A or B) 表示什么意思：<u>当 A 或 B 的值发生变化时触发</u>。</p>
</li>
<li><p>FPGA 的配置信息通常存储在一种叫做<u>Flash</u>的非易失性存储器中。</p>
</li>
<li><p>块语句中，一种是begin-end语句，通常用来标志顺序执行的语句；一种是 fork_join语句，通常用来标志并行执行的语句，在描述需要使用FPG实现的逻辑功能时，两种语句： <u> 均可使用</u>。</p>
</li>
<li><p>FPGA中的逻辑单元（Logic Element，LE）主要用于实现哪种功能： <u>逻辑运算</u>。</p>
</li>
<li><p>FPGA与传统微处理器（如CPU）相比，主要的优势是什么： <u>可编程性和灵活性</u>。</p>
</li>
<li><p>在FPGA设计中，使用哪种文件来描述硬件逻辑：<u>HDL（硬件描述语言）文件</u>。</p>
</li>
<li><p>FPGA编程后，其内部结构是如何连接的： 通过可配置的逻辑块和可编程互连。</p>
</li>
<li><p>哪个公司是FPGA技术的主要供应商之一： <u>Intel</u>。</p>
</li>
<li><p>FPGA中的查找表（LUT）用于实现什么：<u>逻辑函数</u>。</p>
</li>
<li><p>为了在FPGA上实现一个新的设计，工程师通常使用什么过程： <u>综合</u>。</p>
</li>
<li><p>FPGA中的配置数据通常存储在哪里： <u>FLASH</u>。</p>
</li>
<li><p>FPGA的哪个特性使其非常适合用于并行处理任务：<u>大量的逻辑单元</u>。</p>
</li>
<li><p>FPGA上的程序是如何加载的：<u>在开机时通过外部设备加载</u>。</p>
</li>
<li><p>如下程序代码，200ns后，信号q1的值为<u>8’d10</u>。</p>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">`<span class="keyword">timescale</span> 10ns/1ns</span></span><br><span class="line"><span class="keyword">module</span> test;</span><br><span class="line"><span class="keyword">reg</span> [<span class="number">7</span>:<span class="number">0</span>] data;</span><br><span class="line"><span class="keyword">reg</span> clk;</span><br><span class="line"><span class="keyword">initial</span></span><br><span class="line"><span class="keyword">begin</span></span><br><span class="line">  clk = <span class="number">0</span>;</span><br><span class="line">  #<span class="number">10</span>  data = <span class="number">8</span>’d10;</span><br><span class="line">  #<span class="number">20</span>  data = <span class="number">8</span>’h15;</span><br><span class="line">  #<span class="number">40</span>  data = <span class="number">8</span>’h25;</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"><span class="keyword">always</span> #<span class="number">5</span> clk = ~clk;</span><br><span class="line"><span class="keyword">reg</span> [<span class="number">7</span>:<span class="number">0</span>] q1,q2,q3;</span><br><span class="line"><span class="keyword">always</span> @ (<span class="keyword">posedge</span> clk)</span><br><span class="line"><span class="keyword">begin</span></span><br><span class="line">  q2 = q1;</span><br><span class="line">  q1 = data;</span><br><span class="line">  q3 = q2;</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"><span class="keyword">endmodule</span></span><br></pre></td></tr></table></figure></li>
</ol>
<h2 id="二、简答题"><a href="#二、简答题" class="headerlink" title="二、简答题"></a>二、简答题</h2><ol>
<li><p>列举并解释Verilog HDL中常用的几种数据类型,如wire、reg、integer等。并说明它们在设计中的不同应用场景。<br>答：<br>①wire：线网型，通常用于连接模块之间的信号线，传递数据和控制信号，不存储状态，在组合逻辑中使用。<br>②reg：寄存器型，可以存储状态或数据，用于时序逻辑。<br>③Integer：32位带符号整数，通常用于表示计数器。<br>④parameter：通常用于定义常量。</p>
</li>
<li><p>简述Verilog HDL设计的层次结构,并解释module、端口和实例化的作用。<br>答：自顶向下的设计，层次结构包括顶层模块、子模块和实例化模块三个层次；module用于定义模块，可以包含输入端口、输出端口、内部信号和功能实现；端口是模块与外部环境之间的接口，用于输入和输出数据。通过实例化子模块，并通过端口连接来构建整个设计，实现了设计的层次结构和模块化设计。</p>
</li>
<li><p>什么是Verilog中的always块？请给出一个例子说明。<br>答：always块是一种用于描述在特定条件下执行的行为的结构。它可以在特定的事件或条件发生时触发，并且可以用于实现组合逻辑always @(*)和时序逻辑always @(posedge clk or posedge rst)。</p>
</li>
<li><p>forever块和always块的区别是什么？<br>答：always块用于需要根据特定条件触发执行的情况，而forever块为无限循环执行的情况。</p>
</li>
<li><p>Verilog 中的参数和宏的共同点和区别是什么？<br>答：共同：都可以定义常量。区别：作用域不同，参数是模块级别，宏是文件级别；参数一旦定义后就不能更改，宏可以在定义后被重新定义或取消定义；参数可以是任何数据类型，宏通常用于定义简单的文本替换。</p>
</li>
<li><p>Verilog语法中举例表述任务与函数，并说明有何区别？<br>答：<br>任务：可以支持多种目的，能计算多个结果值，这些结果值只能通过被调用的任务的输出或总线端口输出。能够启动其他任务或函数。可以没有或有多个任何类型的变量。没有返回值。</p>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">task</span> &lt;任务名&gt;；</span><br><span class="line">	&lt;端口及数据类声明语句&gt;</span><br><span class="line">	<span class="keyword">begin</span></span><br><span class="line">	&lt;语句<span class="number">1</span>&gt;</span><br><span class="line">	<span class="keyword">end</span></span><br><span class="line"><span class="keyword">endtask</span></span><br><span class="line">例：neg_clocks(<span class="number">3</span>)</span><br></pre></td></tr></table></figure>

<p>函数：通过返回一个值来响应输入信号的值，一般将函数作为表达式中的操作符，这个操作的结果值就是这个函数的返回值。不能启动任务。需要至少一个输入变量。有一个返回值。函数的仿真时间为零。函数的调用不能单独作为一条语句出现。函数定义结构中不允许出现任何的输出端口（output）和输入&#x2F;输出端口（inout）。</p>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span>&lt;返回值类型或返回值宽度&gt; &lt;函数名&gt;;</span><br><span class="line">    &lt;输入端口说明&gt;</span><br><span class="line">    &lt;局部变量说明&gt;</span><br><span class="line">    <span class="keyword">begin</span></span><br><span class="line">    &lt;行为语句<span class="number">1</span>； &gt;</span><br><span class="line">    &lt;行为语句<span class="number">2</span>； &gt;</span><br><span class="line">    …….</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"><span class="keyword">endfunction</span></span><br><span class="line">例：out=getbyte(input1,number); <span class="keyword">assign</span> net1=getbyte ( input1, <span class="number">3</span> );</span><br></pre></td></tr></table></figure>
</li>
<li><p>列举在测试模块中常用的不可综合的命令和对应的功能。<br>答：<br>&lt;!–swig￼24–&gt;monitor：功能：监视一个变量的值，并在该变量的值发生变化时输出消息到控制台。<br><mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.452ex;" xmlns="http://www.w3.org/2000/svg" width="37.591ex" height="2.149ex" role="img" focusable="false" viewBox="0 -750 16615.1 950" xmlns:xlink="http://www.w3.org/1999/xlink"><defs><path id="MJX-7-TEX-I-1D460" d="M131 289Q131 321 147 354T203 415T300 442Q362 442 390 415T419 355Q419 323 402 308T364 292Q351 292 340 300T328 326Q328 342 337 354T354 372T367 378Q368 378 368 379Q368 382 361 388T336 399T297 405Q249 405 227 379T204 326Q204 301 223 291T278 274T330 259Q396 230 396 163Q396 135 385 107T352 51T289 7T195 -10Q118 -10 86 19T53 87Q53 126 74 143T118 160Q133 160 146 151T160 120Q160 94 142 76T111 58Q109 57 108 57T107 55Q108 52 115 47T146 34T201 27Q237 27 263 38T301 66T318 97T323 122Q323 150 302 164T254 181T195 196T148 231Q131 256 131 289Z"></path><path id="MJX-7-TEX-I-1D461" d="M26 385Q19 392 19 395Q19 399 22 411T27 425Q29 430 36 430T87 431H140L159 511Q162 522 166 540T173 566T179 586T187 603T197 615T211 624T229 626Q247 625 254 615T261 596Q261 589 252 549T232 470L222 433Q222 431 272 431H323Q330 424 330 420Q330 398 317 385H210L174 240Q135 80 135 68Q135 26 162 26Q197 26 230 60T283 144Q285 150 288 151T303 153H307Q322 153 322 145Q322 142 319 133Q314 117 301 95T267 48T216 6T155 -11Q125 -11 98 4T59 56Q57 64 57 83V101L92 241Q127 382 128 383Q128 385 77 385H26Z"></path><path id="MJX-7-TEX-I-1D45C" d="M201 -11Q126 -11 80 38T34 156Q34 221 64 279T146 380Q222 441 301 441Q333 441 341 440Q354 437 367 433T402 417T438 387T464 338T476 268Q476 161 390 75T201 -11ZM121 120Q121 70 147 48T206 26Q250 26 289 58T351 142Q360 163 374 216T388 308Q388 352 370 375Q346 405 306 405Q243 405 195 347Q158 303 140 230T121 120Z"></path><path id="MJX-7-TEX-I-1D45D" d="M23 287Q24 290 25 295T30 317T40 348T55 381T75 411T101 433T134 442Q209 442 230 378L240 387Q302 442 358 442Q423 442 460 395T497 281Q497 173 421 82T249 -10Q227 -10 210 -4Q199 1 187 11T168 28L161 36Q160 35 139 -51T118 -138Q118 -144 126 -145T163 -148H188Q194 -155 194 -157T191 -175Q188 -187 185 -190T172 -194Q170 -194 161 -194T127 -193T65 -192Q-5 -192 -24 -194H-32Q-39 -187 -39 -183Q-37 -156 -26 -148H-6Q28 -147 33 -136Q36 -130 94 103T155 350Q156 355 156 364Q156 405 131 405Q109 405 94 377T71 316T59 280Q57 278 43 278H29Q23 284 23 287ZM178 102Q200 26 252 26Q282 26 310 49T356 107Q374 141 392 215T411 325V331Q411 405 350 405Q339 405 328 402T306 393T286 380T269 365T254 350T243 336T235 326L232 322Q232 321 229 308T218 264T204 212Q178 106 178 102Z"></path><path id="MJX-7-TEX-N-3C" d="M694 -11T694 -19T688 -33T678 -40Q671 -40 524 29T234 166L90 235Q83 240 83 250Q83 261 91 266Q664 540 678 540Q681 540 687 534T694 519T687 505Q686 504 417 376L151 250L417 124Q686 -4 687 -5Q694 -11 694 -19Z"></path><path id="MJX-7-TEX-I-1D44F" d="M73 647Q73 657 77 670T89 683Q90 683 161 688T234 694Q246 694 246 685T212 542Q204 508 195 472T180 418L176 399Q176 396 182 402Q231 442 283 442Q345 442 383 396T422 280Q422 169 343 79T173 -11Q123 -11 82 27T40 150V159Q40 180 48 217T97 414Q147 611 147 623T109 637Q104 637 101 637H96Q86 637 83 637T76 640T73 647ZM336 325V331Q336 405 275 405Q258 405 240 397T207 376T181 352T163 330L157 322L136 236Q114 150 114 114Q114 66 138 42Q154 26 178 26Q211 26 245 58Q270 81 285 114T318 219Q336 291 336 325Z"></path><path id="MJX-7-TEX-I-1D45F" d="M21 287Q22 290 23 295T28 317T38 348T53 381T73 411T99 433T132 442Q161 442 183 430T214 408T225 388Q227 382 228 382T236 389Q284 441 347 441H350Q398 441 422 400Q430 381 430 363Q430 333 417 315T391 292T366 288Q346 288 334 299T322 328Q322 376 378 392Q356 405 342 405Q286 405 239 331Q229 315 224 298T190 165Q156 25 151 16Q138 -11 108 -11Q95 -11 87 -5T76 7T74 17Q74 30 114 189T154 366Q154 405 128 405Q107 405 92 377T68 316T57 280Q55 278 41 278H27Q21 284 21 287Z"></path><path id="MJX-7-TEX-N-3E" d="M84 520Q84 528 88 533T96 539L99 540Q106 540 253 471T544 334L687 265Q694 260 694 250T687 235Q685 233 395 96L107 -40H101Q83 -38 83 -20Q83 -19 83 -17Q82 -10 98 -1Q117 9 248 71Q326 108 378 132L626 250L378 368Q90 504 86 509Q84 513 84 520Z"></path><path id="MJX-7-TEX-N-A0" d=""></path></defs><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mi"><use data-c="1D460" xlink:href="#MJX-7-TEX-I-1D460"></use></g><g data-mml-node="mi" transform="translate(469,0)"><use data-c="1D461" xlink:href="#MJX-7-TEX-I-1D461"></use></g><g data-mml-node="mi" transform="translate(830,0)"><use data-c="1D45C" xlink:href="#MJX-7-TEX-I-1D45C"></use></g><g data-mml-node="mi" transform="translate(1315,0)"><use data-c="1D45D" xlink:href="#MJX-7-TEX-I-1D45D"></use></g><g data-mml-node="mi" transform="translate(1818,0)"><text data-variant="italic" transform="scale(1,-1)" font-size="884px" font-family="serif" font-style="italic">：</text></g><g data-mml-node="mi" transform="translate(2818,0)"><text data-variant="normal" transform="scale(1,-1)" font-size="884px" font-family="serif">功</text></g><g data-mml-node="mi" transform="translate(3818,0)"><text data-variant="normal" transform="scale(1,-1)" font-size="884px" font-family="serif">能</text></g><g data-mml-node="mi" transform="translate(4818,0)"><text data-variant="italic" transform="scale(1,-1)" font-size="884px" font-family="serif" font-style="italic">：</text></g><g data-mml-node="mi" transform="translate(5818,0)"><text data-variant="normal" transform="scale(1,-1)" font-size="884px" font-family="serif">停</text></g><g data-mml-node="mi" transform="translate(6818,0)"><text data-variant="normal" transform="scale(1,-1)" font-size="884px" font-family="serif">止</text></g><g data-mml-node="mi" transform="translate(7818,0)"><text data-variant="normal" transform="scale(1,-1)" font-size="884px" font-family="serif">仿</text></g><g data-mml-node="mi" transform="translate(8818,0)"><text data-variant="normal" transform="scale(1,-1)" font-size="884px" font-family="serif">真</text></g><g data-mml-node="mi" transform="translate(9818,0)"><text data-variant="normal" transform="scale(1,-1)" font-size="884px" font-family="serif">过</text></g><g data-mml-node="mi" transform="translate(10818,0)"><text data-variant="normal" transform="scale(1,-1)" font-size="884px" font-family="serif">程</text></g><g data-mml-node="TeXAtom" data-mjx-texclass="ORD" transform="translate(11818,0)"><g data-mml-node="mo"><text data-variant="normal" transform="scale(1,-1)" font-size="884px" font-family="serif">。</text></g></g><g data-mml-node="mo" transform="translate(13095.8,0)"><use data-c="3C" xlink:href="#MJX-7-TEX-N-3C"></use></g><g data-mml-node="mi" transform="translate(14151.6,0)"><use data-c="1D44F" xlink:href="#MJX-7-TEX-I-1D44F"></use></g><g data-mml-node="mi" transform="translate(14580.6,0)"><use data-c="1D45F" xlink:href="#MJX-7-TEX-I-1D45F"></use></g><g data-mml-node="mo" transform="translate(15309.3,0)"><use data-c="3E" xlink:href="#MJX-7-TEX-N-3E"></use></g><g data-mml-node="mtext" transform="translate(16365.1,0)"><use data-c="A0" xlink:href="#MJX-7-TEX-N-A0"></use></g></g></g></svg></mjx-container>finish：功能：完成仿真过程，结束仿真。<br>&lt;!–swig￼26–&gt;time：功能：获取当前仿真时间。<br></p>
</li>
<li><p>Testbench中的时间控制语句有哪些?它们在testbench中的主要作用是什么?请至少列举并解释3种时间控制语句的用法。<br>答：<br># 指令在仿真过程中添加时间延迟。 #10; &#x2F;&#x2F; 延时10个时间单位<br>@ 指令用于等待指定的事件发生。 @(posedge clk); &#x2F;&#x2F; 等待时钟的上升沿<br>wait 指令用于等待条件满足或事件发生。 wait (rst_n &#x3D;&#x3D; 0); &#x2F;&#x2F; 等待复位信号为低电平</p>
</li>
<li><p>如何在testbench中产生随机的输入测试向量?<br>答：使用系统函数 $random。</p>
</li>
<li><p>什么是组合电路的不完全描述？<br>答：组合电路的不完全描述，通常来源于利用Verilog进行逻辑实现时没有给出选择分支的全部映射关系。设计者在代码描述中只给出了部分选择分支所对应的操作，但没有个给出完整的分支映射，在模块综合的时候，有可能生成设计者所不希望的电路结构。</p>
</li>
<li><p>Verilog中如何避免组合逻辑电路的不完全描述？<br>答：包括覆盖所有可能的输入情况，使用完整的 case - default 语句，在 if-else 结构中考虑所有可能的情况，初始化输出信号，使用综合工具等。</p>
</li>
<li><p>简要说明阻塞赋值和非阻塞赋值在写法上和原理上的不同。<br>答：阻塞赋值&#x3D;，顺序执行，在该语句结束时立刻完成赋值操作，完成该赋值语句后才能执行下一句的操作，常用于描述组合逻辑电路。<br>非阻塞赋值&lt;&#x3D;，并行执行，块内的多条赋值语句在块结束时同时赋值，常用于描述时序逻辑电路。</p>
</li>
<li><p>简述同步时序电路和异步时序电路的区别。<br>答：同步时序电路：同步时序电路各个触发器共用一个时钟信号，需要更新状态的触发器在时钟边沿同时翻转。<br>异步时序电路：异步时序电路各个触发器状态的变化不是同步发生的，每一个触发器都有可能有自己单独的触发时钟，异步电路状态的更新没有全局的共用时钟信号。</p>
</li>
<li><p>有限状态机分为哪两类？这两类的有什么区别？<br>答：Moore摩尔型状态机（Moore Machine）和Mealy米勒型状态机（Mealy Machine）。<br>区别：Moore型状态机输出仅依赖于当前状态，不依赖输入信号；Mealy状态机的输出依赖于当前状态和当前输入信号。</p>
</li>
<li><p>简叙三段式状态机的写法。<br>答：三个部分分别是：状态记忆、逻辑转移和逻辑输出。<br>状态记忆：储存当前的逻辑状态。<br>逻辑转移：负责状态机逻辑状态转移，是组合电路。其输入包含当前状态和外部输入信号。<br>逻辑输出：负责逻辑输出的电路部分，摩尔机仅仅与当前状态有关，米勒机与当前状态和输入信号都有关。</p>
</li>
<li><p>简述FPGA与通用处理器和ASIC的区别。<br>答：FPGA:有高度的可编程性，通过硬件描述语言编写的逻辑设计进行配置，能够并行执行多个操作，开发周期较短，灵活性高，单位成本高，适合小批量生产。<br>通用处理器（GPP）：具有广泛适用性，编写软件程序来执行任务，开发环境较成熟，大多数指令是逐条的，适合顺序处理任务。<br>ASIC：具有专用性，可以根据需求定制化，不可重编程，高性能，低功耗，开发周期长，缺乏灵活性，单位成本低，适合大批量生产。</p>
</li>
<li><p>请简述FPGA的基本工作原理和内部硬件架构。<br>答：基本工作原理：用户通过编程配置其内部的可编程逻辑资源，并根据输入信号的变化实时执行特定的功能。<br>内部硬件架构：可配置逻辑块（CLB），可编程互连网络，输入输出（IOB）模块，时钟管理单元，块存储器，数字延迟锁相环（DLL）。</p>
</li>
<li><p>FPGA中的时钟分频器是用来做什么的？为什么在某些设计中需要分频时钟？<br>答：时钟分频器用于将输入时钟信号分频成较低频率的时钟信号。<br>目的：用于降低功耗、提高可靠性、优化性能、满足接口要求以及满足时序约束。</p>
</li>
<li><p>简述FPGA实验中约束文件的作用。<br>答：约束文件（Constraints File），包含了对FPGA设计的各种约束条件，包括时序约束，引脚约束，时钟约束，物理约束，确保设计在FPGA上正确运行并满足性能要求，避免时序问题和布局布线问题，提高设计的稳定性和可靠性。</p>
</li>
<li><p>FPGA设计流程包括哪些主要阶段?请简要说明每个阶段的作用。<br>答：需求分析：明确定义设计的功能需求、性能指标和约束条件。<br>架构设计：设计FPGA系统的整体架构和模块划分。<br>逻辑设计：使用硬件描述语言编写逻辑代码，实现系统功能。<br>综合与优化：将逻辑设计转换为适合FPGA实现的物理电路。<br>验证与仿真：进行功能验证和性能仿真。<br>调试与验证：对FPGA硬件原型进行实际测试和验证。<br>部署与生产：将设计部署到目标FPGA芯片并进行批量生产。<br></p>
</li>
<li><p>简述在FPGA设计流程中，从HDL代码到最终实现经历的主要步骤。<br>答：包括HDL编写，综合布局布线，时序分析和优化，生成位流文，配置FPGA，验证和调试。</p>
</li>
<li><p>解释什么是Verilog，并简述其在电子设计自动化中的作用。<br>答：Verilog HDL 是一种用于描述、设计、仿真、验证数字电子系统的硬件描述语言。<br>以HDL硬件描述语言为代表的自动化设计方法在进行集成电路逻辑仿真、功能验证和布局布线等方面极大地缓解了设计师的劳动强度，从而为高复杂度芯片设计提供了可能。</p>
</li>
<li><p>描述在Verilog中，模块（module）的概念及其重要性。<br>答：模块（module）是一种用于组织和抽象硬件设计的基本单元。一个模块可以包含逻辑、寄存器、子模块以及其他组件，它们一起描述了一个完整的功能单元或电路部分。<br>重要性：模块化设计，可以实现层次化，提高了设计的可维护性和可扩展性，使得模块可以独立开发、测试和重用。</p>
</li>
<li><p>解释Verilog中的连续赋值（continuous assignment）语句和其用途。<br>答：连续赋值是用逻辑值驱动线网，连续赋值语句assign：如，assign c &#x3D; a &amp; b，用于对wire型线网赋值。</p>
</li>
<li><p>说明如何使用Verilog进行时序控制，包括使用always块和时钟信号的示例。<br>答：时序控制通常使用always块结合时钟信号来实现，用于描述在特定条件下执行的行为，如always @(posedge clk or posedge rst)，表示在时钟的上升沿或复位信号触发时执行相应的操作。</p>
</li>
<li><p>什么是Verilog中的always块？请给出一个例子说明。<br>答：always块是一种用于描述在特定条件下执行的行为的结构。它可以在特定的事件或条件发生时触发，并且可以用于实现组合逻辑always @(*)和时序逻辑always @(posedge clk or posedge rst)。</p>
</li>
</ol>
<h2 id="三、代码题"><a href="#三、代码题" class="headerlink" title="三、代码题"></a>三、代码题</h2><ol>
<li><p>设计一个Verilog模块，实现对输入信号的去抖动处理。模块应当在输入信号稳定一定时间后才将其视为有效信号。对于输入信号IN及时钟信号 clk，输入信号为机械按键输入，抖动时间5ms到10ms，时钟频率为50MHz，要求输出1位去抖信号OUT。</p>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">module</span> debounce (</span><br><span class="line">    <span class="keyword">input</span> <span class="keyword">wire</span> clk,        <span class="comment">// 时钟信号</span></span><br><span class="line">    <span class="keyword">input</span> <span class="keyword">wire</span> IN,         <span class="comment">// 输入信号</span></span><br><span class="line">    <span class="keyword">output</span> <span class="keyword">reg</span> OUT         <span class="comment">// 去抖信号</span></span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="keyword">parameter</span> DEBOUNCE_TIME = <span class="number">200000</span>; <span class="comment">// 抖动时间（10ms的时钟周期数）</span></span><br><span class="line"><span class="keyword">reg</span> [<span class="number">31</span>:<span class="number">0</span>] debounce_counter;      <span class="comment">// 去抖计数器</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">always</span> @(<span class="keyword">posedge</span> clk) <span class="keyword">begin</span></span><br><span class="line">    <span class="comment">// 如果输入信号发生变化</span></span><br><span class="line">    <span class="keyword">if</span> (IN != OUT) <span class="keyword">begin</span></span><br><span class="line">        debounce_counter &lt;= debounce_counter + <span class="number">1</span>;</span><br><span class="line">        <span class="comment">// 如果去抖计数器计数达到设定的抖动时间</span></span><br><span class="line">        <span class="keyword">if</span> (debounce_counter &gt;= DEBOUNCE_TIME) <span class="keyword">begin</span></span><br><span class="line">            <span class="comment">// 将输入信号的值赋给去抖信号</span></span><br><span class="line">            OUT &lt;= IN;</span><br><span class="line">            <span class="comment">// 复位去抖计数器</span></span><br><span class="line">            debounce_counter &lt;= <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">    <span class="keyword">end</span> <span class="keyword">else</span> <span class="keyword">begin</span></span><br><span class="line">        <span class="comment">// 如果输入信号保持稳定，复位去抖计数器</span></span><br><span class="line">        debounce_counter &lt;= <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">endmodule</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>输入复位高有效信号sys_rst、时钟信号sys_clk、进位输入信号cin、两个一位的加数a、b，输出一位的和sum以及进位输出信号cout。给出各信号的真值表：<br><img src="/2024/05/17/FPGA-%E5%A4%8D%E4%B9%A0%E8%B5%84%E6%96%99/17128281194GOS.png" alt="img"></p>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">module</span> one_bit_adder_with_reset (</span><br><span class="line">    <span class="keyword">input</span> <span class="keyword">wire</span> sys_rst,   <span class="comment">// 复位信号（高有效）</span></span><br><span class="line">    <span class="keyword">input</span> <span class="keyword">wire</span> sys_clk,   <span class="comment">// 时钟信号</span></span><br><span class="line">    <span class="keyword">input</span> <span class="keyword">wire</span> cin,       <span class="comment">// 进位输入信号</span></span><br><span class="line">    <span class="keyword">input</span> <span class="keyword">wire</span> a,         <span class="comment">// 第一个加数</span></span><br><span class="line">    <span class="keyword">input</span> <span class="keyword">wire</span> b,         <span class="comment">// 第二个加数</span></span><br><span class="line">    <span class="keyword">output</span> <span class="keyword">reg</span> sum,       <span class="comment">// 和</span></span><br><span class="line">    <span class="keyword">output</span> <span class="keyword">reg</span> cout       <span class="comment">// 进位输出信号</span></span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 在时钟上升沿处检测复位信号</span></span><br><span class="line"><span class="keyword">always</span> @(<span class="keyword">posedge</span> sys_clk <span class="keyword">or</span> <span class="keyword">posedge</span> sys_rst) <span class="keyword">begin</span></span><br><span class="line">    <span class="keyword">if</span> (sys_rst) <span class="keyword">begin</span></span><br><span class="line">        <span class="comment">// 在复位信号为高时，重置sum和cout</span></span><br><span class="line">        sum &lt;= <span class="number">1&#x27;b0</span>;</span><br><span class="line">        cout &lt;= <span class="number">1&#x27;b0</span>;</span><br><span class="line">    <span class="keyword">end</span> <span class="keyword">else</span> <span class="keyword">begin</span></span><br><span class="line">        <span class="comment">// 正常工作状态，计算和与进位</span></span><br><span class="line">        sum &lt;= a ^ b ^ cin;</span><br><span class="line">        cout &lt;= (a &amp; b) | (cin &amp; (a ^ b));</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">endmodule</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>输入复位高有效信号sys_rst、时钟信号sys_clk、进位输入信号cin、两个两位的加数a、b，输出两位的和sum以及进位输出信号cout。要求例化两个一位加法器来实现多位加法器的功能。</p>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">module</span> two_bit_adder_with_reset (</span><br><span class="line">    <span class="keyword">input</span> <span class="keyword">wire</span> sys_rst,     <span class="comment">// 复位信号（高有效）</span></span><br><span class="line">    <span class="keyword">input</span> <span class="keyword">wire</span> sys_clk,     <span class="comment">// 时钟信号</span></span><br><span class="line">    <span class="keyword">input</span> <span class="keyword">wire</span> cin,         <span class="comment">// 进位输入信号</span></span><br><span class="line">    <span class="keyword">input</span> <span class="keyword">wire</span> [<span class="number">1</span>:<span class="number">0</span>] a,     <span class="comment">// 第一个两位加数</span></span><br><span class="line">    <span class="keyword">input</span> <span class="keyword">wire</span> [<span class="number">1</span>:<span class="number">0</span>] b,     <span class="comment">// 第二个两位加数</span></span><br><span class="line">    <span class="keyword">output</span> <span class="keyword">reg</span> [<span class="number">1</span>:<span class="number">0</span>] sum,   <span class="comment">// 两位的和</span></span><br><span class="line">    <span class="keyword">output</span> <span class="keyword">reg</span> cout         <span class="comment">// 进位输出信号</span></span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="keyword">wire</span> c1; <span class="comment">// 第一位的进位</span></span><br><span class="line"><span class="keyword">wire</span> c2; <span class="comment">// 第二位的进位</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 实例化两个一位加法器</span></span><br><span class="line">one_bit_adder_with_reset adder0(</span><br><span class="line">    <span class="variable">.sys_rst</span>(sys_rst),</span><br><span class="line">    <span class="variable">.sys_clk</span>(sys_clk),</span><br><span class="line">    <span class="variable">.cin</span>(cin),</span><br><span class="line">    <span class="variable">.a</span>(a[<span class="number">0</span>]),</span><br><span class="line">    <span class="variable">.b</span>(b[<span class="number">0</span>]),</span><br><span class="line">    <span class="variable">.sum</span>(sum[<span class="number">0</span>]),</span><br><span class="line">    <span class="variable">.cout</span>(c1)</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line">one_bit_adder_with_reset adder1(</span><br><span class="line">    <span class="variable">.sys_rst</span>(sys_rst),</span><br><span class="line">    <span class="variable">.sys_clk</span>(sys_clk),</span><br><span class="line">    <span class="variable">.cin</span>(c1),</span><br><span class="line">    <span class="variable">.a</span>(a[<span class="number">1</span>]),</span><br><span class="line">    <span class="variable">.b</span>(b[<span class="number">1</span>]),</span><br><span class="line">    <span class="variable">.sum</span>(sum[<span class="number">1</span>]),</span><br><span class="line">    <span class="variable">.cout</span>(c2)</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 进位输出为最高位的进位</span></span><br><span class="line"><span class="keyword">assign</span> cout = c2;</span><br><span class="line"></span><br><span class="line"><span class="keyword">endmodule</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>实现一个模块，将3位二进制数a转换为对应的3位格雷码b。格雷码与二进制码转换表如下：<br><img src="/2024/05/17/FPGA-%E5%A4%8D%E4%B9%A0%E8%B5%84%E6%96%99/1713147786RRSU.png" alt="img"></p>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">module</span> binary_to_gray (</span><br><span class="line">    <span class="keyword">input</span> [<span class="number">2</span>:<span class="number">0</span>] a,  <span class="comment">// 3位二进制数输入</span></span><br><span class="line">    <span class="keyword">output</span> <span class="keyword">reg</span> [<span class="number">2</span>:<span class="number">0</span>] b <span class="comment">// 3位格雷码输出</span></span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 格雷码的最高位等于二进制的最高位</span></span><br><span class="line"><span class="keyword">assign</span> b[<span class="number">2</span>] = a[<span class="number">2</span>];</span><br><span class="line"></span><br><span class="line"><span class="comment">// 其余位的计算</span></span><br><span class="line"><span class="keyword">always</span> @(*) <span class="keyword">begin</span></span><br><span class="line">    b[<span class="number">1</span>] = a[<span class="number">2</span>] ^ a[<span class="number">1</span>];</span><br><span class="line">    b[<span class="number">0</span>] = a[<span class="number">1</span>] ^ a[<span class="number">0</span>];</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">endmodule</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>比较两个4位二进制数，并输出三个标志：等于c1、大于c2、小于c3。输入信号a，b为4位有符号二进制数，输出高电平有效。</p>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">module</span> binary_comparator (</span><br><span class="line">    <span class="keyword">input</span> [<span class="number">3</span>:<span class="number">0</span>] a,     <span class="comment">// 第一个4位有符号二进制数</span></span><br><span class="line">    <span class="keyword">input</span> [<span class="number">3</span>:<span class="number">0</span>] b,     <span class="comment">// 第二个4位有符号二进制数</span></span><br><span class="line">    <span class="keyword">output</span> <span class="keyword">reg</span> c1,     <span class="comment">// 等于标志</span></span><br><span class="line">    <span class="keyword">output</span> <span class="keyword">reg</span> c2,     <span class="comment">// 大于标志</span></span><br><span class="line">    <span class="keyword">output</span> <span class="keyword">reg</span> c3      <span class="comment">// 小于标志</span></span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="keyword">always</span> @(*) <span class="keyword">begin</span></span><br><span class="line">    <span class="keyword">if</span> (a == b) <span class="keyword">begin</span></span><br><span class="line">        c1 = <span class="number">1&#x27;b1</span>;  <span class="comment">// 等于标志</span></span><br><span class="line">        c2 = <span class="number">1&#x27;b0</span>;  <span class="comment">// 大于标志</span></span><br><span class="line">        c3 = <span class="number">1&#x27;b0</span>;  <span class="comment">// 小于标志</span></span><br><span class="line">    <span class="keyword">end</span> <span class="keyword">else</span> <span class="keyword">if</span> (a &gt; b) <span class="keyword">begin</span></span><br><span class="line">        c1 = <span class="number">1&#x27;b0</span>;</span><br><span class="line">        c2 = <span class="number">1&#x27;b1</span>;</span><br><span class="line">        c3 = <span class="number">1&#x27;b0</span>;</span><br><span class="line">    <span class="keyword">end</span> <span class="keyword">else</span> <span class="keyword">begin</span></span><br><span class="line">        c1 = <span class="number">1&#x27;b0</span>;</span><br><span class="line">        c2 = <span class="number">1&#x27;b0</span>;</span><br><span class="line">        c3 = <span class="number">1&#x27;b1</span>;</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">endmodule</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>生成一个伪随机二进制序列，序列每个时钟周期更新一次。输入时钟为clk，输出信号为8位二进制序列out。</p>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">module</span> lfsr_generator (</span><br><span class="line">    <span class="keyword">input</span> <span class="keyword">wire</span> clk,      <span class="comment">// 时钟信号</span></span><br><span class="line">    <span class="keyword">output</span> <span class="keyword">reg</span> [<span class="number">7</span>:<span class="number">0</span>] out <span class="comment">// 8位二进制序列输出</span></span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="keyword">reg</span> [<span class="number">7</span>:<span class="number">0</span>] lfsr_reg;    <span class="comment">// LFSR 寄存器</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">always</span> @(<span class="keyword">posedge</span> clk) <span class="keyword">begin</span></span><br><span class="line">    <span class="comment">// 计算下一个 LFSR 的值</span></span><br><span class="line">    lfsr_reg[<span class="number">0</span>] = lfsr_reg[<span class="number">7</span>] ^ lfsr_reg[<span class="number">3</span>];</span><br><span class="line">    lfsr_reg[<span class="number">1</span>] = lfsr_reg[<span class="number">0</span>];</span><br><span class="line">    lfsr_reg[<span class="number">2</span>] = lfsr_reg[<span class="number">1</span>];</span><br><span class="line">    lfsr_reg[<span class="number">3</span>] = lfsr_reg[<span class="number">2</span>];</span><br><span class="line">    lfsr_reg[<span class="number">4</span>] = lfsr_reg[<span class="number">3</span>];</span><br><span class="line">    lfsr_reg[<span class="number">5</span>] = lfsr_reg[<span class="number">4</span>];</span><br><span class="line">    lfsr_reg[<span class="number">6</span>] = lfsr_reg[<span class="number">5</span>];</span><br><span class="line">    lfsr_reg[<span class="number">7</span>] = lfsr_reg[<span class="number">6</span>];</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 输出当前 LFSR 的值</span></span><br><span class="line">    out &lt;= lfsr_reg;</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">endmodule</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>实现一个8位串行输入、并行输出的移位寄存器。输入时钟clk，每一时钟周期读取一次输入信号IN的值，将其置于八位输出信号out的最低位，前一时钟周期输出信号0到6位作为输出信号的高7位。</p>
</li>
</ol>
   <figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">module</span> shift_register (</span><br><span class="line">    <span class="keyword">input</span> <span class="keyword">wire</span> clk,      <span class="comment">// 时钟信号</span></span><br><span class="line">    <span class="keyword">input</span> <span class="keyword">wire</span> IN,       <span class="comment">// 串行输入信号</span></span><br><span class="line">    <span class="keyword">output</span> <span class="keyword">reg</span> [<span class="number">7</span>:<span class="number">0</span>] out <span class="comment">// 并行输出信号</span></span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="keyword">reg</span> [<span class="number">6</span>:<span class="number">0</span>] reg_out; <span class="comment">// 移位寄存器的高7位</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">always</span> @(<span class="keyword">posedge</span> clk) <span class="keyword">begin</span></span><br><span class="line">    <span class="comment">// 将上一时钟周期的输出信号的低7位移动到高7位</span></span><br><span class="line">    reg_out &lt;= out[<span class="number">6</span>:<span class="number">0</span>];</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将当前输入信号放置于最低位</span></span><br><span class="line">    out &lt;= &#123;IN, reg_out[<span class="number">6</span>]&#125;;</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">endmodule</span></span><br></pre></td></tr></table></figure>

<ol start="8">
<li><p>创建一个Verilog模块，实现4选1多路选择器（MUX）。输入包括四个数据输入信号a、b、c、d，两个选择信号s0、s1和一个输出信号y。具体真值表如下：<br><img src="/2024/05/17/FPGA-%E5%A4%8D%E4%B9%A0%E8%B5%84%E6%96%99/1712828194F9VM.png" alt="img"></p>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">module</span> mux_4to1 (</span><br><span class="line">    <span class="keyword">input</span> <span class="keyword">wire</span> s0,   <span class="comment">// 选择信号 s0</span></span><br><span class="line">    <span class="keyword">input</span> <span class="keyword">wire</span> s1,   <span class="comment">// 选择信号 s1</span></span><br><span class="line">    <span class="keyword">input</span> <span class="keyword">wire</span> [<span class="number">3</span>:<span class="number">0</span>] a,  <span class="comment">// 数据输入信号 a</span></span><br><span class="line">    <span class="keyword">input</span> <span class="keyword">wire</span> [<span class="number">3</span>:<span class="number">0</span>] b,  <span class="comment">// 数据输入信号 b</span></span><br><span class="line">    <span class="keyword">input</span> <span class="keyword">wire</span> [<span class="number">3</span>:<span class="number">0</span>] c,  <span class="comment">// 数据输入信号 c</span></span><br><span class="line">    <span class="keyword">input</span> <span class="keyword">wire</span> [<span class="number">3</span>:<span class="number">0</span>] d,  <span class="comment">// 数据输入信号 d</span></span><br><span class="line">    <span class="keyword">output</span> <span class="keyword">reg</span> [<span class="number">3</span>:<span class="number">0</span>] y   <span class="comment">// 输出信号 y</span></span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="keyword">always</span> @(*) <span class="keyword">begin</span></span><br><span class="line">    <span class="keyword">case</span>(&#123;s1, s0&#125;)</span><br><span class="line">        <span class="number">2&#x27;b00</span>: y = a;  <span class="comment">// s1=0, s0=0</span></span><br><span class="line">        <span class="number">2&#x27;b01</span>: y = b;  <span class="comment">// s1=0, s0=1</span></span><br><span class="line">        <span class="number">2&#x27;b10</span>: y = c;  <span class="comment">// s1=1, s0=0</span></span><br><span class="line">        <span class="number">2&#x27;b11</span>: y = d;  <span class="comment">// s1=1, s0=1</span></span><br><span class="line">        <span class="keyword">default</span>: y = <span class="number">4&#x27;bxxxx</span>; <span class="comment">// 默认情况，输出未定义</span></span><br><span class="line">    <span class="keyword">endcase</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">endmodule</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>设计一个具有同步复位功能的T触发器。确保复位信号rst为高时，输出Q被置为0。当时钟上升沿时，如果T和Q不相同时，其输出值Q会是1。输入端T为1的时候，输出端的状态Q发生反转；输入端T为0的时候，输出端的状态Q保持不变：<br><img src="/2024/05/17/FPGA-%E5%A4%8D%E4%B9%A0%E8%B5%84%E6%96%99/1712828213XGGP.png" alt="img"></p>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">module</span> t_flip_flop_with_reset (</span><br><span class="line">    <span class="keyword">input</span> <span class="keyword">wire</span> clk,  <span class="comment">// 时钟信号</span></span><br><span class="line">    <span class="keyword">input</span> <span class="keyword">wire</span> rst,  <span class="comment">// 复位信号（高电平有效）</span></span><br><span class="line">    <span class="keyword">input</span> <span class="keyword">wire</span> T,    <span class="comment">// T触发器输入信号</span></span><br><span class="line">    <span class="keyword">output</span> <span class="keyword">reg</span> Q     <span class="comment">// Q输出信号</span></span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 同步复位逻辑</span></span><br><span class="line"><span class="keyword">always</span> @(<span class="keyword">posedge</span> clk <span class="keyword">or</span> <span class="keyword">posedge</span> rst) <span class="keyword">begin</span></span><br><span class="line">    <span class="keyword">if</span> (rst) <span class="keyword">begin</span></span><br><span class="line">        Q &lt;= <span class="number">1&#x27;b0</span>; <span class="comment">// 复位时输出Q置为0</span></span><br><span class="line">    <span class="keyword">end</span> <span class="keyword">else</span> <span class="keyword">begin</span></span><br><span class="line">        <span class="comment">// T触发器逻辑</span></span><br><span class="line">        <span class="keyword">if</span> (T != Q) <span class="keyword">begin</span></span><br><span class="line">            Q &lt;= ~Q; <span class="comment">// T和Q不相同时，输出值Q反转</span></span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">endmodule</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>设计一个4位二进制上升沿触发计数器，具有异步清零功能，即在复位信号置0时，无论时钟信号为何值，输出都将清零。确保计数器在达到最大值后能够循环计数。</p>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">module</span> counter (</span><br><span class="line">    <span class="keyword">input</span> <span class="keyword">wire</span> clk,  <span class="comment">// 时钟信号</span></span><br><span class="line">    <span class="keyword">input</span> <span class="keyword">wire</span> rst,  <span class="comment">// 异步清零信号</span></span><br><span class="line">    <span class="keyword">output</span> <span class="keyword">reg</span> [<span class="number">3</span>:<span class="number">0</span>] count <span class="comment">// 计数器输出</span></span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="keyword">always</span> @(<span class="keyword">posedge</span> clk <span class="keyword">or</span> <span class="keyword">negedge</span> rst) <span class="keyword">begin</span></span><br><span class="line">    <span class="keyword">if</span> (!rst) <span class="keyword">begin</span></span><br><span class="line">        count &lt;= <span class="number">4&#x27;b0000</span>; <span class="comment">// 清零</span></span><br><span class="line">    <span class="keyword">end</span> <span class="keyword">else</span> <span class="keyword">begin</span></span><br><span class="line">        <span class="keyword">if</span> (count == <span class="number">4&#x27;b1111</span>) <span class="keyword">begin</span></span><br><span class="line">            count &lt;= <span class="number">4&#x27;b0000</span>; <span class="comment">// 计数达到最大值后清零</span></span><br><span class="line">        <span class="keyword">end</span> <span class="keyword">else</span> <span class="keyword">begin</span></span><br><span class="line">            count &lt;= count + <span class="number">1</span>; <span class="comment">// 正常计数</span></span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">endmodule</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>创建一个Verilog模块，将输入时钟信号clk_0进行四倍分频，输出较低频率的时钟信号clk_1，即clk_1输出频率应为输入时钟频率的四分之一。</p>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">module</span> clock_divider (</span><br><span class="line">    <span class="keyword">input</span> <span class="keyword">wire</span> clk_0,   <span class="comment">// 输入时钟信号</span></span><br><span class="line">    <span class="keyword">output</span> <span class="keyword">reg</span> clk_1    <span class="comment">// 输出时钟信号</span></span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="keyword">reg</span> [<span class="number">1</span>:<span class="number">0</span>] count;  <span class="comment">// 计数器</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">always</span> @(<span class="keyword">posedge</span> clk_0) <span class="keyword">begin</span></span><br><span class="line">    count &lt;= count + <span class="number">1</span>;  <span class="comment">// 每个时钟周期计数器加一</span></span><br><span class="line">    <span class="keyword">if</span> (count == <span class="number">2&#x27;b11</span>) <span class="keyword">begin</span></span><br><span class="line">        count &lt;= <span class="number">2&#x27;b00</span>;  <span class="comment">// 计数到3时归零</span></span><br><span class="line">        clk_1 &lt;= ~clk_1; <span class="comment">// 输出时钟信号翻转</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">endmodule</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>编写一个模块，将4位二进制输入x转换为驱动7段LED显示的信号，输出信号为高电平时，对应数码管亮起。输入信号记作x，输出信号led[0]到led[6]分别对应数码管a到g段。<br><img src="/2024/05/17/FPGA-%E5%A4%8D%E4%B9%A0%E8%B5%84%E6%96%99/1712828261PITO.png" alt="img"></p>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">module</span> binary_to_7seg(</span><br><span class="line">    <span class="keyword">input</span> [<span class="number">3</span>:<span class="number">0</span>] x,</span><br><span class="line">    <span class="keyword">output</span> <span class="keyword">reg</span> [<span class="number">6</span>:<span class="number">0</span>] led</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="keyword">always</span> @(*) <span class="keyword">begin</span></span><br><span class="line">    <span class="keyword">case</span> (x)</span><br><span class="line">        <span class="number">4&#x27;b0000</span>: led = <span class="number">7&#x27;b1000000</span>; <span class="comment">// 数字0</span></span><br><span class="line">        <span class="number">4&#x27;b0001</span>: led = <span class="number">7&#x27;b1111001</span>; <span class="comment">// 数字1</span></span><br><span class="line">        <span class="number">4&#x27;b0010</span>: led = <span class="number">7&#x27;b0100100</span>; <span class="comment">// 数字2</span></span><br><span class="line">        <span class="number">4&#x27;b0011</span>: led = <span class="number">7&#x27;b0110000</span>; <span class="comment">// 数字3</span></span><br><span class="line">        <span class="number">4&#x27;b0100</span>: led = <span class="number">7&#x27;b0011001</span>; <span class="comment">// 数字4</span></span><br><span class="line">        <span class="number">4&#x27;b0101</span>: led = <span class="number">7&#x27;b0010010</span>; <span class="comment">// 数字5</span></span><br><span class="line">        <span class="number">4&#x27;b0110</span>: led = <span class="number">7&#x27;b0000010</span>; <span class="comment">// 数字6</span></span><br><span class="line">        <span class="number">4&#x27;b0111</span>: led = <span class="number">7&#x27;b1111000</span>; <span class="comment">// 数字7</span></span><br><span class="line">        <span class="number">4&#x27;b1000</span>: led = <span class="number">7&#x27;b0000000</span>; <span class="comment">// 数字8</span></span><br><span class="line">        <span class="number">4&#x27;b1001</span>: led = <span class="number">7&#x27;b0010000</span>; <span class="comment">// 数字9</span></span><br><span class="line">        <span class="keyword">default</span>: led = <span class="number">7&#x27;b1111111</span>; <span class="comment">// 显示空白</span></span><br><span class="line">    <span class="keyword">endcase</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">endmodule</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>设计一个简单的4位ALU，支持至少四种操作：加法、减法、按位与、按位或。ALU应包括操作2位选择输入sel、两个4位操作数a、b输入和一个输出c。选择输入不同时进行不同运算操作即可，选择输入与运算操作的对应规则不做要求。默认a大于b。</p>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">module</span> alu(</span><br><span class="line">    <span class="keyword">input</span> [<span class="number">1</span>:<span class="number">0</span>] sel,</span><br><span class="line">    <span class="keyword">input</span> [<span class="number">3</span>:<span class="number">0</span>] a,</span><br><span class="line">    <span class="keyword">input</span> [<span class="number">3</span>:<span class="number">0</span>] b,</span><br><span class="line">    <span class="keyword">output</span> <span class="keyword">reg</span> [<span class="number">3</span>:<span class="number">0</span>] c</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="keyword">always</span> @(*) <span class="keyword">begin</span></span><br><span class="line">    <span class="keyword">case</span> (sel)</span><br><span class="line">        <span class="number">2&#x27;b00</span>: c = a + b; <span class="comment">// 加法</span></span><br><span class="line">        <span class="number">2&#x27;b01</span>: c = a - b; <span class="comment">// 减法</span></span><br><span class="line">        <span class="number">2&#x27;b10</span>: c = a &amp; b; <span class="comment">// 按位与</span></span><br><span class="line">        <span class="number">2&#x27;b11</span>: c = a | b; <span class="comment">// 按位或</span></span><br><span class="line">        <span class="keyword">default</span>: c = <span class="number">4&#x27;b0000</span>; <span class="comment">// 默认情况</span></span><br><span class="line">    <span class="keyword">endcase</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">endmodule</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>已知模块my_module()中，有八位输入信号in[7:0]，复位信号rst，以及八位输出信号out[7:0]。请编写对应的testbench文件，要求：输入信号每100ns变化一次，循环遍历所有输入情况；复位信号在仿真开始后500ns到600ns之间为高电平，其余时间为低电平。</p>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">`<span class="keyword">timescale</span> 1ns / 1ps </span><span class="comment">// 设置时间刻度</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">module</span> testbench;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义测试信号</span></span><br><span class="line"><span class="keyword">reg</span> [<span class="number">7</span>:<span class="number">0</span>] in;</span><br><span class="line"><span class="keyword">reg</span> rst;</span><br><span class="line"><span class="keyword">wire</span> [<span class="number">7</span>:<span class="number">0</span>] out;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 实例化被测试的模块</span></span><br><span class="line">my_module dut(</span><br><span class="line">    <span class="variable">.in</span>(in),</span><br><span class="line">    <span class="variable">.rst</span>(rst),</span><br><span class="line">    <span class="variable">.out</span>(out)</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义仿真时钟</span></span><br><span class="line"><span class="keyword">initial</span> <span class="keyword">begin</span></span><br><span class="line">    <span class="comment">// 初始化输入</span></span><br><span class="line">    in = <span class="number">8&#x27;b00000000</span>;</span><br><span class="line">    rst = <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 仿真开始后的处理</span></span><br><span class="line">    #<span class="number">500</span> rst = <span class="number">1</span>; <span class="comment">// 将复位信号设置为高电平</span></span><br><span class="line">    #<span class="number">100</span> rst = <span class="number">0</span>; <span class="comment">// 恢复为低电平</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 循环遍历所有输入情况</span></span><br><span class="line">    <span class="keyword">repeat</span> (<span class="number">256</span>) <span class="keyword">begin</span></span><br><span class="line">        <span class="comment">// 在每个输入情况下仿真100ns</span></span><br><span class="line">        #<span class="number">100</span> in = in + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 结束仿真</span></span><br><span class="line">    <span class="built_in">$finish</span>;</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">endmodule</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>已知模块my_module_1()与my_module_2()。对于my_module_1()，有输入信号clk与输出信号clk_0，其作用是将输入的时钟变频为所需频率的时钟；对于my_module_2()，有输入信号clk，复位信号rst（高电平有效），以及八位输出信号out[7:0]。请编写对应的testbench文件，要求：系统时钟频率为50MHz；观察在经过my_module_1()处理前后的时钟控制下的两out信号之和（记作tb_out[7:0]）。</p>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">`<span class="keyword">timescale</span> 1ns / 1ps </span><span class="comment">// 设置时间刻度</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">module</span> testbench;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义测试信号</span></span><br><span class="line"><span class="keyword">reg</span> clk;</span><br><span class="line"><span class="keyword">reg</span> rst;</span><br><span class="line"><span class="keyword">wire</span> [<span class="number">7</span>:<span class="number">0</span>] out_1, out_2;</span><br><span class="line"><span class="keyword">wire</span> [<span class="number">7</span>:<span class="number">0</span>] tb_out;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 实例化被测试的模块</span></span><br><span class="line">my_module_1 dut1(</span><br><span class="line">    <span class="variable">.clk</span>(clk),</span><br><span class="line">    <span class="variable">.clk_0</span>(clk_0)</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line">my_module_2 dut2(</span><br><span class="line">    <span class="variable">.clk</span>(clk_0), <span class="comment">// 使用经过变频后的时钟信号</span></span><br><span class="line">    <span class="variable">.rst</span>(rst),</span><br><span class="line">    <span class="variable">.out</span>(out_1)</span><br><span class="line">);</span><br><span class="line">    </span><br><span class="line">my_module_2 dut3(</span><br><span class="line">    <span class="variable">.clk</span>(clk_0), <span class="comment">// 使用经过变频后的时钟信号</span></span><br><span class="line">    <span class="variable">.rst</span>(rst),</span><br><span class="line">    <span class="variable">.out</span>(out_2)</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 初始化时钟</span></span><br><span class="line"><span class="keyword">initial</span> <span class="keyword">begin</span></span><br><span class="line">    clk = <span class="number">0</span>;</span><br><span class="line">    rst = <span class="number">1</span>; <span class="comment">// 复位信号处于高电平状态</span></span><br><span class="line">    #<span class="number">100</span>; <span class="comment">// 等待一段时间</span></span><br><span class="line">    rst = <span class="number">0</span>; <span class="comment">// 复位信号拉低，开始正常工作</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 生成时钟</span></span><br><span class="line"><span class="keyword">always</span> <span class="keyword">begin</span></span><br><span class="line">    #<span class="number">10</span> clk = ~clk; <span class="comment">// 每10个时间单位翻转一次时钟</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 将两个输出信号相加</span></span><br><span class="line"><span class="keyword">assign</span> tb_out = out_1 + out_2;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 结束仿真</span></span><br><span class="line"><span class="keyword">initial</span> <span class="keyword">begin</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>有如下图所示的矩阵键盘，请填补程序中的空缺，使得key1按下时输出led[0]为高电平，key2按下时输出led[1]为高电平，以此类推。<img src="/2024/05/17/FPGA-%E5%A4%8D%E4%B9%A0%E8%B5%84%E6%96%99/17128283311VUZ.png" alt="img"></p>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">module</span> keyboard(</span><br><span class="line">    <span class="keyword">input</span> clk,</span><br><span class="line">    <span class="keyword">input</span> rst_n,</span><br><span class="line">    <span class="keyword">input</span> [<span class="number">3</span>:<span class="number">0</span>]PD3_0,</span><br><span class="line">    <span class="keyword">output</span> <span class="keyword">reg</span> [<span class="number">7</span>:<span class="number">4</span>]PD7_4,</span><br><span class="line">    <span class="keyword">output</span> <span class="keyword">reg</span> [<span class="number">15</span>:<span class="number">0</span>]led</span><br><span class="line">    );</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">always</span>@(<span class="keyword">posedge</span> clk <span class="keyword">or</span> <span class="keyword">posedge</span> rst_n)<span class="keyword">begin</span></span><br><span class="line">        <span class="keyword">if</span>(rst_n)PD7_4 &lt;= <span class="number">4&#x27;b0001</span>;</span><br><span class="line">        <span class="keyword">else</span> PD7_4[<span class="number">7</span>:<span class="number">4</span>] &lt;= &#123;PD7_4[<span class="number">6</span>:<span class="number">4</span>],PD7_4[<span class="number">7</span>]&#125;;</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">    <span class="comment">//作答时请从此处开始</span></span><br><span class="line">    <span class="keyword">always</span>@(<span class="keyword">posedge</span> clk)<span class="keyword">begin</span></span><br><span class="line">        <span class="keyword">case</span>(&#123;PD7_4[<span class="number">7</span>:<span class="number">4</span>],PD3_0[<span class="number">3</span>:<span class="number">0</span>]&#125;)</span><br><span class="line">            </span><br><span class="line">            <span class="comment">//以下为补充代码</span></span><br><span class="line">            <span class="number">8&#x27;b0001_1000</span>:led &lt;= <span class="number">16&#x27;b0000_0000_0000_0001</span>;</span><br><span class="line">            <span class="number">8&#x27;b0010_1000</span>:led &lt;= <span class="number">16&#x27;b0000_0000_0000_0010</span>;</span><br><span class="line">            <span class="number">8&#x27;b0100_1000</span>:led &lt;= <span class="number">16&#x27;b0000_0000_0000_0100</span>;</span><br><span class="line">            <span class="number">8&#x27;b1000_1000</span>:led &lt;= <span class="number">16&#x27;b0000_0000_0000_1000</span>;</span><br><span class="line">            </span><br><span class="line">            <span class="number">8&#x27;b0001_0100</span>:led &lt;= <span class="number">16&#x27;b0000_0000_0001_0000</span>;</span><br><span class="line">            <span class="number">8&#x27;b0010_0100</span>:led &lt;= <span class="number">16&#x27;b0000_0000_0010_0000</span>;</span><br><span class="line">            <span class="number">8&#x27;b0100_0100</span>:led &lt;= <span class="number">16&#x27;b0000_0000_0100_0000</span>;</span><br><span class="line">            <span class="number">8&#x27;b1000_0100</span>:led &lt;= <span class="number">16&#x27;b0000_0000_1000_0000</span>;</span><br><span class="line">            </span><br><span class="line">            <span class="number">8&#x27;b0001_0010</span>:led &lt;= <span class="number">16&#x27;b0000_0001_0000_0000</span>;</span><br><span class="line">            <span class="number">8&#x27;b0010_0010</span>:led &lt;= <span class="number">16&#x27;b0000_0010_0000_0000</span>;</span><br><span class="line">            <span class="number">8&#x27;b0100_0010</span>:led &lt;= <span class="number">16&#x27;b0000_0100_0000_0000</span>;</span><br><span class="line">            <span class="number">8&#x27;b1000_0010</span>:led &lt;= <span class="number">16&#x27;b0000_1000_0000_0000</span>;</span><br><span class="line">            </span><br><span class="line">            <span class="number">8&#x27;b0001_0001</span>:led &lt;= <span class="number">16&#x27;b0001_0000_0000_0000</span>;</span><br><span class="line">            <span class="number">8&#x27;b0010_0001</span>:led &lt;= <span class="number">16&#x27;b0010_0000_0000_0000</span>;</span><br><span class="line">            <span class="number">8&#x27;b0100_0001</span>:led &lt;= <span class="number">16&#x27;b0100_0000_0000_0000</span>;</span><br><span class="line">            <span class="number">8&#x27;b1000_0001</span>:led &lt;= <span class="number">16&#x27;b1000_0000_0000_0000</span>;</span><br><span class="line">            <span class="comment">//以上为补充代码</span></span><br><span class="line">            </span><br><span class="line">            <span class="keyword">default</span>     :led &lt;= <span class="number">16&#x27;b0000_0000_0000_0000</span>; </span><br><span class="line">        <span class="keyword">endcase</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"><span class="comment">//作答时请在此处结束</span></span><br><span class="line"><span class="keyword">endmodule</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>请补充代码中缺失的部分，用于声控灯的控制。当有声音时，输入信号sound为高电平，否则为低电平，输入clk为50kHz时钟，输入rst为异步复位信号，高电平有效；输出信号为led，高电平时表示灯泡亮起。要求：系统初始状态灯泡不亮，直到接收到声音，灯泡亮起，持续3s；灯泡亮起时，若接收到声音，不会改变灯泡剩余点亮时间。</p>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">module</span> sound_led(</span><br><span class="line">    <span class="keyword">input</span> sound,</span><br><span class="line">    <span class="keyword">input</span> clk,</span><br><span class="line">    <span class="keyword">input</span> rst,</span><br><span class="line">    <span class="keyword">output</span> <span class="keyword">reg</span> led</span><br><span class="line">    );</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">reg</span> [<span class="number">3</span>:<span class="number">0</span>] state;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">reg</span> flag_3s;</span><br><span class="line">    <span class="keyword">reg</span> [<span class="number">31</span>:<span class="number">0</span>]cnt;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">parameter</span> IDLE  = <span class="number">3&#x27;d0</span>,</span><br><span class="line">              START = <span class="number">3&#x27;d1</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">parameter</span> CLK_FRE = <span class="number">50_000</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">always</span>@(<span class="keyword">posedge</span> clk <span class="keyword">or</span> <span class="keyword">posedge</span> rst)<span class="keyword">begin</span></span><br><span class="line">        <span class="keyword">if</span>(rst)<span class="keyword">begin</span></span><br><span class="line">            state &lt;= IDLE;</span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">begin</span></span><br><span class="line">            <span class="keyword">case</span> (state)</span><br><span class="line">                IDLE  :<span class="keyword">if</span>(sound)state &lt;= START;</span><br><span class="line">                START :<span class="keyword">if</span>(flag_3s)state &lt;= IDLE;</span><br><span class="line">                <span class="keyword">default</span> : state &lt;= IDLE;</span><br><span class="line">            <span class="keyword">endcase</span></span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">always</span> @(<span class="keyword">posedge</span> clk)<span class="keyword">begin</span></span><br><span class="line">        <span class="keyword">case</span> (state)</span><br><span class="line">            IDLE  :<span class="keyword">begin</span></span><br><span class="line">                cnt &lt;= CLK_FRE*<span class="number">3</span>;</span><br><span class="line">                led &lt;= <span class="number">0</span>;</span><br><span class="line">                flag_3s &lt;= <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">end</span></span><br><span class="line">            START :<span class="keyword">begin</span></span><br><span class="line">            <span class="comment">// 以下为补充代码</span></span><br><span class="line">                cnt=cnt-<span class="number">1</span>;</span><br><span class="line">                led &lt;= <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">if</span>(~cnt)flag_3s &lt;= <span class="number">1</span>;</span><br><span class="line">            <span class="comment">// 以上为补充代码</span></span><br><span class="line">            <span class="keyword">end</span></span><br><span class="line">            <span class="keyword">default</span>:<span class="keyword">begin</span></span><br><span class="line">                cnt &lt;= CLK_FRE*<span class="number">3</span>;</span><br><span class="line">                led &lt;= <span class="number">0</span>;</span><br><span class="line">                flag_3s &lt;= <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">end</span></span><br><span class="line">        <span class="keyword">endcase</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">endmodule</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>请为上题中的声控灯控制器编写相应的testbench文件，要求测试声控灯控制器的所有功能。</p>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">`<span class="keyword">timescale</span> 1ns / 1ps</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">module</span> sound_led_tb;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 定义测试信号</span></span><br><span class="line">    <span class="keyword">reg</span> sound;</span><br><span class="line">    <span class="keyword">reg</span> clk;</span><br><span class="line">    <span class="keyword">reg</span> rst;</span><br><span class="line">    <span class="keyword">wire</span> led;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 实例化被测试的模块</span></span><br><span class="line">    sound_led dut (</span><br><span class="line">        <span class="variable">.sound</span>(sound),</span><br><span class="line">        <span class="variable">.clk</span>(clk),</span><br><span class="line">        <span class="variable">.rst</span>(rst),</span><br><span class="line">        <span class="variable">.led</span>(led)</span><br><span class="line">    );</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 时钟发生器</span></span><br><span class="line">    <span class="keyword">always</span> <span class="keyword">begin</span></span><br><span class="line">        #<span class="number">10</span> clk = ~clk; <span class="comment">// 50kHz的时钟</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 产生声音信号</span></span><br><span class="line">    <span class="keyword">initial</span> <span class="keyword">begin</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 正常持续3s亮起功能</span></span><br><span class="line">        sound = <span class="number">0</span>;</span><br><span class="line">        #<span class="number">100</span>; <span class="comment">// 等待一段时间</span></span><br><span class="line">        sound = <span class="number">1</span>; <span class="comment">// 使声音信号为高电平</span></span><br><span class="line">        #<span class="number">200</span>; <span class="comment">// 持续一段时间</span></span><br><span class="line">        sound = <span class="number">0</span>; <span class="comment">// 关闭声音信号</span></span><br><span class="line">        #<span class="number">4000000000</span>; <span class="comment">// 等待足够长的时间，确保灯泡亮起3秒以上</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 在持续时间内声音信号高电平持续时间不重复计算</span></span><br><span class="line">        sound = <span class="number">1</span>; <span class="comment">// 使声音信号为高电平</span></span><br><span class="line">        #<span class="number">200</span>; <span class="comment">// 持续一段时间</span></span><br><span class="line">        sound = <span class="number">0</span>; <span class="comment">// 关闭声音信号</span></span><br><span class="line">        #<span class="number">1000000000</span>; <span class="comment">// 延时1s</span></span><br><span class="line">        sound = <span class="number">1</span>; <span class="comment">// 使声音信号为高电平</span></span><br><span class="line">        #<span class="number">200</span>; <span class="comment">// 持续一段时间</span></span><br><span class="line">        sound = <span class="number">0</span>; <span class="comment">// 关闭声音信号</span></span><br><span class="line">        </span><br><span class="line">        <span class="built_in">$finish</span>; <span class="comment">// 结束仿真</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 复位控制</span></span><br><span class="line">    <span class="keyword">initial</span> <span class="keyword">begin</span></span><br><span class="line">        rst = <span class="number">1</span>;</span><br><span class="line">        #<span class="number">100</span>; <span class="comment">// 持续一段时间</span></span><br><span class="line">        rst = <span class="number">0</span>; <span class="comment">// 撤销复位</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">endmodule</span></span><br></pre></td></tr></table></figure></li>
</ol>

    </div>

    
    
    

      <footer class="post-footer">
          <div class="post-tags">
              <a href="/tags/FPGA/" rel="tag"># FPGA</a>
          </div>

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/2024/04/18/%E7%94%B5%E5%AD%90%E7%94%B5%E8%B7%AF-%E5%AE%9E%E9%AA%8C-%E5%B0%84%E7%BA%A7%E8%B7%9F%E9%9A%8F%E5%99%A8/" rel="prev" title="电子电路-实验-射级跟随器">
      <i class="fa fa-chevron-left"></i> 电子电路-实验-射级跟随器
    </a></div>
      <div class="post-nav-item"></div>
    </div>
      </footer>
    
  </article>
  
  
  



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#FPGA%E5%A4%8D%E4%B9%A0%E8%B5%84%E6%96%99"><span class="nav-number">1.</span> <span class="nav-text">FPGA复习资料</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%80%9D%E7%BB%B4%E5%AF%BC%E5%9B%BE"><span class="nav-number">1.1.</span> <span class="nav-text">思维导图</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%B8%80%E3%80%81%E5%8D%95%E9%80%89%E9%A2%98%EF%BC%88%E4%BB%85%E7%BB%99%E5%87%BA%E7%AD%94%E6%A1%88%EF%BC%89"><span class="nav-number">1.2.</span> <span class="nav-text">一、单选题（仅给出答案）</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BA%8C%E3%80%81%E7%AE%80%E7%AD%94%E9%A2%98"><span class="nav-number">1.3.</span> <span class="nav-text">二、简答题</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%B8%89%E3%80%81%E4%BB%A3%E7%A0%81%E9%A2%98"><span class="nav-number">1.4.</span> <span class="nav-text">三、代码题</span></a></li></ol></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">wykcat</p>
  <div class="site-description" itemprop="description">摆烂是种特别的选择</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">16</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">4</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">5</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; Wed Mar 06 2024 08:00:00 GMT+0800 (中国标准时间) – 
  <span itemprop="copyrightYear">2024</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">wykcat</span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-chart-area"></i>
    </span>
    <span title="站点总字数">34k</span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-coffee"></i>
    </span>
    <span title="站点阅读时长">31 分钟</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Gemini</a> 强力驱动
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>




  















  

  

  

</body>
</html>
